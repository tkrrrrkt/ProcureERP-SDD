# Tech Steering – 調達管理SaaS

## 1. 全体アーキテクチャ方針

- 構成
  - フロントエンド：Next.js App Router（v16 系） + React 19.2 + TypeScript
  - UI フレームワーク：Tailwind CSS v4 + shadcn/ui
  - バックエンド API：Node.js LTS + NestJS
  - データベース：PostgreSQL（マネージドサービス）
  - 非同期処理：Redis + BullMQ（メール送信・PDF生成・一部外部連携用）
  - ORM / スキーマ管理：Prisma
- アーキテクチャスタイル
  - バックエンドは **モジュラーモノリス** として構成し、ドメイン単位でモジュール分割する。
  - 将来的なマイクロサービス化を見据えつつも、MVP〜当面は 1 リポジトリ / 1 デプロイを基本とする。
- マルチテナント
  - 1DB マルチテナント方式を採用する。
  - `tenant_id` カラム＋Row Level Security (RLS) による行レベル制御を基本とし、必要に応じて将来的にスキーマ分割を検討する。

本プロダクトでは、UI は v0 推奨のアーキテクチャ（Next.js + React 19.2 + Tailwind v4 + shadcn/ui）に準拠し、  
バックエンドは NestJS によるモジュラーモノリス構成とする。

---

## 2. フロントエンド（Next.js / React / Tailwind / shadcn）

### 2-1. 基本スタック

- Next.js App Router（v16 系）
- React 19.2
- TypeScript（strict モード）
- Tailwind CSS v4
- shadcn/ui コンポーネントライブラリ

### 2-2. アプリ構成方針

- ディレクトリ例：
  - `apps/web`：Next.js アプリ本体
  - `apps/web/app/`：App Router ベースのルーティング構成
  - 認証系ルート：`apps/web/app/(auth)/...`
  - 業務系ルート：`apps/web/app/(dashboard)/...`
  - 共通 UI コンポーネント：`apps/web/components/`
- デザインシステム：
  - shadcn/ui をベースに、「調達SaaS用の UI パターン（一覧、フィルタ、承認ステータスバッジ等）」を共通コンポーネント化する。
  - カラー・タイポグラフィ・余白は Tailwind の `theme` カスタマイズで統一する。
  - 金額表示コンポーネント（Intl.NumberFormat ラッパー）を早期に用意し、通貨表記・桁区切りを統一する。
- データフェッチ：
  - クライアントサイドのデータ取得・キャッシュには SWR または TanStack Query の採用を検討する。
  - App Router の Server Actions との併用方針は、実装フェーズの PoC を踏まえて本ファイルに反映する。
- v0 との整合：
  - v0 から生成された UI コードは、`apps/web/app/(feature)/...` 配下に配置する。
  - 入出力の型・API 契約は、バックエンド（NestJS）側の DTO / Prisma モデルと整合させる。
  - v0 プロンプトでは「Next.js App Router v16 + React 19.2 + Tailwind v4 + shadcn/ui + TypeScript」を明示する。
  - `any` 型の多用は禁止し、バックエンドの DTO 型を import して型安全性を確保する。
  - **v0のIntegration Wizardは使用しない**（Supabase前提のため、NestJSプロジェクトでは不適合）
  - v0でUIのみを生成し、API連携はCursor + NestJSで実装する
  - 詳細なワークフローは `.kiro/steering/v0-workflow.md` を参照

---

## 3. バックエンド（NestJS モジュラーモノリス）

### 3-1. 基本スタック

- Node.js LTS
- NestJS
- TypeScript
- Prisma（PostgreSQL 用）
- 金額計算：Prisma.Decimal または decimal.js 等の任意精度ライブラリ

### 3-2. モジュール構成方針

- NestJS の Module 単位で構成し、`.kiro/steering/structure.md` の Context / Feature と対応させる。

例：

- `CorePlatformModule`
  - 認証・認可・テナント管理
  - 組織・社員・ロール・権限・承認ルート
  - 伝票共通（伝票種類・採番・カレンダー等）
  - ロギング・監査基盤
- `MasterDataModule`
  - 取引先・仕入先・納入先・支払条件・銀行口座
  - 品目・品目Ver・仕入先品目・単位・カテゴリ・倉庫グループ・税区分・勘定科目
- `PurchasingFlowModule`
  - 購買依頼・見積・発注・入荷・仕入の各ユースケースを Application Service として実装
- `IntegrationModule`（将来）
  - 会計・ERP・EC サイトなど外部連携

### 3-3. Clean Architecture / DDD の考え方

- NestJS Module 配下に `domain / application / infra` の 3 階層を設ける。
  - domain：エンティティ・値オブジェクト・ドメインサービス
  - application：UseCase / ApplicationService
  - infra：Prisma Repository・外部APIクライアント・ジョブキューなど
- ドメインの用語・ルールは `.kiro/specs/domain/*.md` を先に更新し、コードはそれに追随させる（Spec-first）。

### 3-4. 金額・数量の型ポリシー

- 金額・数量などの数値は、浮動小数点数（JavaScript の `number`）では扱わない。
- データベースでは `DECIMAL(p, s)` 型を使用する（例：金額は `DECIMAL(15, 2)` を基本とし、必要に応じて調整）。
- Prisma では `Decimal` 型を利用し、計算には `Prisma.Decimal` または `decimal.js` 等の任意精度ライブラリを使用する。
- `.cursor/rules` にも「金額計算に `number` を使用しないこと」を明記し、AI生成コードでも徹底する。

---

## 4. データベース・マルチテナント・Prisma

### 4-1. PostgreSQL

- マネージド PostgreSQL（クラウド）を利用する。
- テーブル名・カラム名は snake_case を基本ルールとする。
- 1つの物理 DB インスタンス上で複数テナントをホストする。

### 4-2. tenant_id とマルチテナント方針（MVP）

- 本プロダクトは 1DB マルチテナント方式を採用し、**業務データはすべて `tenant_id` を持つ** ことを原則とする。
  - 対象：組織・社員・アカウント・ロール・承認ルート・取引先・仕入先・品目・在庫関連・各種伝票（購買依頼／見積／発注／入荷／仕入）・ログ等、テナント固有のデータ。
  - 例外：国コード・通貨コード等、「全テナント共通でよいと明確に判断できるリファレンスマスタ」のみ、`tenant_id` なしのグローバルテーブルとすることを許容する。
- アプリケーションコードでは、業務データへのアクセス時に必ず `tenant_id` を明示する。
  - リクエストコンテキストから取得した `tenant_id` を Repository / Prisma に渡す。
  - 「`tenant_id` を指定しない SELECT / UPDATE / DELETE」は禁止とする。

### 4-3. Row Level Security (RLS) 方針

- `tenant_id` を持つ業務テーブルには、原則すべて PostgreSQL の Row Level Security (RLS) を適用する。
  - 対象：組織・社員・アカウント・ロール・承認ルート・取引先・仕入先・品目・在庫関連・各種伝票（購買依頼／見積／発注／入荷／仕入）・ログ等。
- RLS ポリシーの基本ルール：
  - セッションコンテキストに保持した `tenant_id`（例：接続時に設定するアプリケーションパラメータ）と行の `tenant_id` が一致する行のみ、SELECT / INSERT / UPDATE / DELETE を許可する。
  - システム管理者など、ごく限定されたロールのみ、運用・障害調査用途としてテナント境界をまたいだ参照ができる専用ポリシーを定義する。
- アプリケーション側でも必ず `tenant_id` を明示し、
  「アプリ側で `tenant_id` を付け忘れたが、RLS によってブロックされる」という二重防御を前提とする。
- RLS の有効／無効やポリシー定義は、Prisma のマイグレーション（SQL）として管理し、仕様変更時には `.kiro/specs/*/design.md` にも反映する。

### 4-4. Prisma と RLS の連携方針

- Prisma はコネクションプールを利用するため、RLS 用コンテキスト（例：`app.current_tenant`）はセッションローカル設定で扱う。
- アプローチ案：
  - Prisma Client Extensions / Middleware を利用し、クエリ実行前に `SET LOCAL app.current_tenant = :tenantId` を実行する仕組みを導入する。
  - もしくは Repository 層で必ず `tenant_id` を WHERE 条件に含める抽象化を行い、生の Prisma Client をドメイン層から直接呼ばない。
- どの方式を採用するかは PoC の結果で最終決定し、決定後に本ファイルおよび関連する `design.md` に具体化する。

### 4-5. Prisma モデル設計とマイグレーション

- `schema.prisma` は `.kiro/specs/domain/*.md` と `.kiro/specs/*/design.md` を元に生成・更新する。
- ID 設計：
  - 主キーは基本 UUID を採用し、伝票番号などの業務コードとは分離する。
  - 伝票番号・コードは別カラムで管理し、採番ロジックは Domain Service に実装する。
- マイグレーション：
  - Prisma Migrate を利用し、DB スキーマ変更は必ずマイグレーションとして管理する。
  - RLS の Policy 定義（SQL）は Prisma の `migrations/xxxx/migration.sql` に手動で追記して管理する。

---

## 5. 競合制御（楽観ロック・悲観ロック）

### 5-1. マスタ系：楽観ロック

- 取引先・仕入先・品目・支払条件・承認ルート等のマスタは、**楽観ロック** を基本とする。
- 実装方針：
  - マスタテーブルに `version`（整数）カラムを設けるか、PostgreSQL の `xmin` 相当を利用する。
  - 更新時には、取得時の `version` を WHERE 条件に含めて UPDATE し、更新件数が 0 の場合は競合（他ユーザーによる先行更新）とみなす。
  - 競合時はユーザーに「他のユーザーによって更新されています」のメッセージを返し、再取得を促す。

### 5-2. 伝票系：悲観ロック

- 購買依頼・見積・発注・入荷・仕入などの伝票データは、編集競合を避けるため **悲観ロック** を採用する。
- 方針イメージ：
  - 編集開始時に、「伝票単位の編集ロック」を取得する（DBレベルの `SELECT ... FOR UPDATE` または専用ロックテーブルを利用）。
  - ロック取得済みの伝票は、同一ユーザー以外による編集操作を拒否する（閲覧は許可）。
  - 一定時間操作がない場合や明示的なキャンセル／保存完了時にはロックを解放する。
- 悲観ロックの具体実装は、`feature-xxx/design.md`（伝票系の設計）で詳細を詰める。

---

## 6. API 設計・フロントとの契約

- API スタイル：
  - MVP 時点では REST API を基本とし、NestJS Controller でエンドポイントを公開する。
- DTO / 型共有：
  - DTO / Response 型は TypeScript で定義し、`packages/dto`（または `libs/dto`）としてバックエンド・フロントエンドの双方から参照する。
  - フロント側は、この DTO 型を元に API クライアントを実装し、`any` の利用を極力排除する。
- エラーハンドリング：
  - ドメインエラー（ビジネスルール違反）とシステムエラー（例外）は区別する。
  - ドメインエラーは HTTP 400 番台、システムエラーは 500 番台を基本とする。
  - エラーレスポンスは原則として RFC 7807 "Problem Details for HTTP APIs" に準拠した JSON 形式とし、
    `type` / `title` / `status` / `detail` / `instance` を返す。
- バリデーション：
  - DTO レベルで class-validator 等を用いて入力検証を行い、
  - ドメイン層ではビジネスルールレベルの検証を行う二段構えとする。

---

## 7. 開発プロセス・SDD / AI 利用

### 7-1. 仕様駆動開発（SDD）

- `.kiro/specs/feature-*` 配下の
  - `requirements.md`
  - `design.md`
  - `tasks.md`
  を仕様の SSOT（Single Source of Truth）とする。
- 新機能は必ず以下の順で進める：
  1. `/kiro:spec-init`
  2. `/kiro:spec-requirements`
  3. `/kiro:spec-design`
  4. `/kiro:spec-tasks`
  5. `/kiro:spec-impl`
- 仕様を変更せずにコードだけを書き換えることを禁止し、PR レビューで spec との整合性を確認する。

### 7-2. AI ツール（Cursor / v0）の利用ルール

- Cursor：
  - `.cursor/rules` に以下のようなルールを定義する：
    - 金額・数量の計算に `number` を使わないこと（必ず `Decimal` を利用）。
    - Prisma へのアクセスは Repository 経由に限定し、生の `prisma.$queryRaw` 等を直接呼ばないこと。
  - `.kiro/specs/` を常に Context として読み込ませた状態でコード生成・編集を行う。
- v0（UI 生成）：
  - `v0.md` / `ui-*.md` に UI 用プロンプトを定義し、Next.js + React + Tailwind + shadcn 構成で UI を生成させる。
  - 生成された UI コードは、要求仕様（requirements）と型定義（design）と照合し、人間がレビューする。

---

## 8. テスト・品質管理

- テスト戦略（ピラミッド）：
  - Unit Test（Jest / Vitest）：
    - ドメインサービス、エンティティ、金額計算、バリデーション。
  - Integration Test：
    - Repository 層（実 DB コンテナに接続し、RLS の挙動確認を含む）。
  - E2E Test（Playwright / Cypress）：
    - 購買依頼〜承認〜発注〜入荷〜仕入など、主要ハッピーパスのシナリオ。
- カバレッジ目標（MVP）：
  - ドメインサービス：80%以上
  - アプリケーションサービス：60%以上
  - 主要ユースケースの E2E：フローごとに最低 1 本は用意する。
- CI パイプライン：
  - PR 作成時に Lint / Build / Unit Test を必須実行とする。

---

## 9. ログ・監査・トレーシング

### 9-1. アプリケーションログ

- 構造化ログ（JSON）を採用し、`info / warn / error` を明確に分ける。
- 機微情報（パスワード・TOTPシークレット・口座番号など）はログに出力しない。

### 9-2. 監査ログポリシー（MVP）

- 目的：
  - 調達プロセスに関する重要な操作の履歴を残し、内部統制・監査・トラブルシュートに耐えられる証跡を提供する。
- 監査対象イベント（MVP想定）：
  - ログイン／ログアウト
  - パスワードリセットの開始・完了
  - MFA（TOTP）の有効化・無効化・リセット
  - 伝票関連：
    - 購買依頼・見積・発注・入荷・仕入の「作成」「更新」「承認」「差戻し」「取消」「削除」
  - マスタ関連：
    - 取引先・仕入先・納入先・支払条件・銀行口座
    - 品目・品目Ver・仕入先品目
    - 承認ルート・ロール／権限設定
    の「作成」「重要な属性変更」「無効化／削除」
- 記録内容（最低限）：
  - 実行ユーザー（ユーザーID、`tenant_id`）
  - イベント種別（例：LOGIN、PR_CREATE、PO_APPROVE、VENDOR_UPDATE 等）
  - 対象リソース（テーブル名・主キー等）
  - 実行日時（タイムスタンプ）
  - 実行結果（成功／失敗、失敗時の理由）
  - 必要に応じて主要な変更内容（Before / After の要約または差分）
- 実装方針：
  - アプリケーション層（UseCase / ApplicationService）で監査イベントを発行し、専用の監査ログテーブルに永続化する。
  - 監査ログは論理削除を禁止し、必要に応じてマスキング・アーカイブで対応する。
  - 監査ログへのアクセスは権限制御を行い、閲覧できるロールを限定する。

### 9-3. 監査ログテーブルのスケーラビリティ

- 監査ログ（audit_logs）は長期的に件数が増加する前提のため、PostgreSQL のパーティショニングを前提とした設計とする。
- パーティショニング方針（案）：
  - 月単位（例：`audit_logs_2025_01`、`audit_logs_2025_02` ...）でのレンジパーティション。
  - 古いパーティションのアーカイブ・削除を容易にする。
- MVP で即パーティションを有効にするかどうかは負荷・実装コストを見て判断するが、
  スキーマ設計・マイグレーション設計はパーティショニングを前提にしておく。

### 9-4. トレーシング

- 余裕があれば OpenTelemetry 互換の APM を導入し、主要ユースケースのレイテンシを可視化する。
- まずは API レイテンシ・DBクエリ時間・外部API呼び出し時間が追えることを目標とする。

---

## 10. セキュリティポリシー

### 10-1. 認証方式（MVP）

- 認証は当面、アプリ内の ID/パスワード認証を採用する。
  - ログイン ID：メールアドレス（テナント内で一意）
  - パスワードはサーバ側でハッシュ化して保存する（Argon2 または bcrypt を利用）。
- 多要素認証（MFA）は **必須** とし、TOTP（認証アプリ）方式を採用する。
  - ユーザーは初回ログインまたは招待完了時に、認証アプリ（Google Authenticator / Microsoft Authenticator 等）で TOTP を登録する。
  - 登録フローでは QR コード or シークレットキーを提示し、6桁コードの入力で有効化を確認する。
  - 通常ログイン時は「メールアドレス＋パスワード」に加え、「TOTP 6桁コード」の入力を必須とする。
  - TOTP シークレットキーは DB に暗号化して保存し、アプリケーションキー or KMS により復号する。
- SSO（Azure AD / Google Workspace 等の IdP 連携）は、MVP 以降の拡張機能としてロードマップに載せる。

### 10-2. MFA（TOTP）のリカバリ方針

- ユーザーが TOTP を利用できなくなった場合（端末紛失・機種変更等）のリカバリは、MVP では「管理者リセット」のみを提供する。
- テナント管理者（またはシステム管理者）は、本人確認の上で該当ユーザーの MFA 設定をリセットし、再度 TOTP 登録フローを実行させる。
- バックアップコード（リカバリコード）は MVP では提供しない（将来の拡張候補とする）。

### 10-3. パスワードポリシー（MVP）

- 最低文字数：8文字以上
- 必須文字種：
  - 英字（大文字・小文字はどちらか一方でも可）
  - 数字
- 記号の使用：任意（セキュリティ向上のため推奨）
- パスワード有効期限：
  - 原則として定期変更は求めない（MFA を必須とする前提で、過度な定期変更は要求しない）。
- 再利用制限：
  - 直近 N 回（目安：3回）のパスワードは再利用不可。
- 保存方法：
  - 強度の高いハッシュ関数（Argon2 または bcrypt）でハッシュ化し、平文では保持しない。
- パスワードリセット：
  - パスワードを忘れた場合は、登録メールアドレス宛のリセットリンクによる再設定フローを提供する。
  - リセットリンクには有効期限を設け、一度使用したリンクは再利用できない。

### 10-4. アカウントロック / ログイン失敗ポリシー（MVP）

- ログイン試行時のパスワード／MFAコードの失敗回数をカウントし、ブルートフォース攻撃を防止する。
- 基本方針（案）：
  - 同一ユーザーIDで **5回連続** ログインに失敗した場合、そのユーザーアカウントを **15分間ロック** する。
  - ロック期間中はログイン試行を拒否し、「一定回数以上の失敗によりロックされています」とのみ通知する（詳細理由は表示しない）。
  - ロック解除は原則時間経過による自動解除とし、必要に応じて管理者が管理画面から手動解除できるようにする。
- IP アドレスや User-Agent 単位でのレートリミットは、WAF やリバースプロキシ側の機能も併用して検討する。
- ロック状態やログイン失敗回数は監査ログにも記録し、異常な試行が続くテナント／ユーザーは運用側でモニタリングできるようにする。

### 10-5. セッション管理ポリシー（MVP）

- セッションの基本方針：
  - 業務利用のしやすさを重視しつつ、過度にログイン頻度が増えないよう、
    「SaaS寄り（数日〜1週間程度のログイン継続）」を前提とする。
- セッション寿命（案）：
  - 最大寿命（リフレッシュセッション）：7日
    - ログイン成功時に、ブラウザの HttpOnly クッキーとして長命セッション情報（リフレッシュ用トークン）を発行する。
    - 7日を超えた場合は再ログインを要求する。
  - アイドルタイムアウト：12時間
    - 最後の操作から 12時間以上経過した場合は、自動的にログアウトし、再ログイン画面に遷移させる。
- 実装イメージ：
  - 短寿命のアクセストークン（例：有効期限 60分）と、長寿命のリフレッシュトークン（有効期限 7日）を組み合わせる。
  - リフレッシュトークンは HttpOnly / Secure クッキーで保存し、JavaScript からは参照できないようにする。
  - ログアウト時は、アクセストークンの無効化およびリフレッシュトークンの破棄を行う。

### 10-6. ロール・権限（RBAC）の方針（MVP時点）

- 本プロダクトではロール・権限モデル（RBAC）を採用するが、詳細なロール構成・権限粒度は、
  購買依頼・承認ワークフロー等の業務要件定義（requirements）と合わせて設計する。
- MVP時点では最低限のロール（例：テナント管理者 / 一般ユーザー 等）のみを先に用意し、
  承認機能・閲覧範囲の要件が固まり次第、ロール定義と権限定義を `specs/domain/*.md` および本ファイルに反映する。
- RBACの詳細設計は、`feature-purchase-request` などの承認フローを設計するタイミングで行う。

### 10-7. 暗号化ポリシー（MVP）

- 通信の暗号化（in transit）：
  - クライアント〜サーバ間の通信はすべて HTTPS/TLS を必須とする。
  - DB への接続も TLS を利用し、平文接続は許可しない。
- データ保管の暗号化（at rest）：
  - データベースはクラウドプロバイダ標準の「暗号化 at rest」を有効にしたマネージド PostgreSQL を利用する。
  - アプリケーションサーバ側のディスク／オブジェクトストレージも、可能な限りクラウド側の暗号化機能を利用する。
- アプリケーションレベルのカラム暗号化：
  - 特に機微性の高い情報については、アプリケーション側でカラム単位の暗号化を行う。
  - 暗号化対象の例（MVP想定）：
    - 銀行口座番号
    - 支払先の口座名義
    - 場合によっては担当者の個人メールアドレス・電話番号など、個人識別性の高い連絡先情報
  - 暗号化方式：
    - 対称鍵暗号（例：AES-256-GCMなど）を用いてアプリケーション層で暗号化／復号を行う。
    - 暗号鍵は平文でDBに保存せず、環境変数またはクラウドの KMS（Key Management Service）で管理する（将来的な KMS 移行を前提）。
- ログとマスキング：
  - ログに機微情報（口座番号・個人メール・電話番号等）を出力しない。
  - 必要に応じて UI・エクスポート機能では一部情報をマスキング（例：下4桁のみ表示）する。
  - 監査ログには、原則として機微情報の「値」ではなく、「どのレコードが変更されたか」のメタ情報を残す。

---

## 11. 非同期処理・ジョブキュー

- 目的：
  - API レスポンス時間を安定させ、メール送信・PDF生成・外部連携などの重い処理を非同期に逃がす。
- 対象となる処理（例）：
  - 見積依頼メール送信
  - 発注書メール送信
  - 注文書・見積書等の PDF 生成
  - 将来的な会計システム・ERP・EC サイトとのバッチ連携
- 技術スタック（案）：
  - Redis + BullMQ
  - NestJS の `@nestjs/bull` を利用してジョブキューを実装する。
- ジョブ設計の原則：
  - ジョブは **idempotent（冪等）** となるように設計する。
    - 同じ伝票ID＋ジョブ種別のジョブが複数回実行されても、メール二重送信・PDF二重生成が発生しないようにする。
    - 例：ジョブキー（`tenant_id + document_id + job_type`）で一意制御する、送信済みフラグを持つ等。
  - 重要なジョブはジョブログまたは監査ログに記録し、失敗時にはリトライとアラート通知を行う。
  - ジョブキューは API からは「投入するだけ」とし、結果確認は別の画面・ログで行う。

---

## 12. バックアップ / リストア方針（検討中）

- 本番データベースについては、クラウドプロバイダが提供する自動バックアップ機能を前提とする。
- ただし、具体的なバックアップ頻度・保持期間・リストア手順・テナント単位の復旧方針については、
  MVP のスケールや利用状況を見ながら後続フェーズで詳細設計を行う。
- 決定時に検討する観点（メモ）：
  - バックアップ頻度（例：日次、実行時刻）
  - 保持期間（例：7日／30日／90日 など）
  - 誤操作やデータ破損時の復旧単位（DB全体／テナント単位／伝票単位 等）
  - DR / BCP（障害・災害時の復旧目標：RPO / RTO）
- 本セクションは「検討中」として扱い、方針が固まり次第 `.kiro/steering/tech.md` および関連する `design.md` に反映する。



